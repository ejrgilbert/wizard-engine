// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Parses and updates monitor options based on arguments.
component MonitorOptions {
	var group = OptionsRegistry.newGroup("MONITOR", printHelp);
	def CSV = group.newBoolOption("csv", false, "Enable comma-separated value output for monitors.");
	def X_ = OptionsRegistry.addParseFunc(parse);
	
	private var monitors = Vector<Monitor>.new();

	// Parse a command-line argument, configuring and updating monitors. Return {true}
	// if the argument was matched and parsed successfully.
	def parse(arg: string) -> bool {
		if (!Strings.startsWith(arg, "--monitors=")) return false;
		var s = 11, pos = s;
		var inArg = false;
		while (pos < arg.length) {
			match (arg[pos]) {
				'{' => {
					var name = Arrays.range(arg, s, pos);
					var args_start = ++pos, args_end = arg.length;
					while (pos < arg.length) {
						var ch = arg[pos++];
						if (ch == '}') { args_end = pos-1; break; }
					}
					var args = Arrays.range(arg, args_start, args_end);
					addMonitor(name, args);
					s = pos;
				}
				',' => {
					var name = Arrays.range(arg, s, pos);
					addMonitor(name, null);
					s = ++pos;
				}
				_ => pos++;
			}
		}
		if (s < arg.length) addMonitor(Arrays.range(arg, s, arg.length), null);
		return true;
	}
	private def addMonitor(name: string, args: string) {
		if (Strings.endsWith(name, ".wasm")) {
			var engine = Engine.new();
			engine.extensions = Extension.set.all;
			var tiering_override = if(SpcTuning.compileWhammModules, ExecuteOptions.getModeOrDefault("jit"), Execute.tiering);

			// Split by '+'
			var s = 0, pos = s;
			var whammModuleName = "";
			var otherModuleNames = Vector<string>.new();
			while (pos < name.length) {
				match (name[pos]) {
					'+' => {
						var name = Arrays.range(name, s, pos);

						// First module is the whamm module, otherwise it's a library to link
						if (whammModuleName.length == 0) {
							whammModuleName = name;
						} else {
							otherModuleNames.put(name);
						}
						s = pos + 1;
						pos++;
					}
					_ => pos++;
				}
			}
			// If whamm module hasn't been set yet, we don't have any libraries to link
			var finalName = Arrays.range(name, s, pos);
			if (!Strings.endsWith(finalName, ".wasm")) {
				ErrorBuilder.new()
					.puts(finalName)
					.puts(": unknown file format, expected .wasm\n")
					.exit(4);
				return;
			}
			if (whammModuleName.length == 0) {
				whammModuleName = finalName;
			} else {
				// add the last module to link!
				otherModuleNames.put(finalName);
			}

			var whammModule = loadModule(engine, whammModuleName, tiering_override, "wizeng: could not load monitor file ");
			if (whammModule == null) return; // Something bad happened during load

			// If there are library modules to link, instantiate them here and save them to a group specific to this Whamm monitor.
			var toLink = Vector<(string, Module)>.new();
			if (otherModuleNames.length > 0) {
				for (i < otherModuleNames.length) {
					var name = otherModuleNames[i];
					var module = loadModule(engine, name, tiering_override, "wizeng: could not load monitor library file ");
					if (module == null) return; // Something bad happened during load
					toLink.put((name, module));
				}
			}
			monitors.put(WhammMonitor.new((whammModuleName, whammModule), toLink));
			return;
		}
		var entry = MonitorRegistry.lookupName(name);
		if (entry != null) {
			if (args != null) {
				parseMonitorArgs(entry, args);
				var msg = entry.monitor.configure(args);
				if (msg != null) Trace.OUT.put2("%s: %s", name, msg).ln();
			}
			monitors.put(entry.monitor);
		}
	}
	private def loadModule(engine: Engine, path: string, tiering_override: ExecutionStrategy, onError: string) -> Module {
		var result = engine.loadWasmFileWithTiering(path, tiering_override); // TODO: limits
		match (result) {
			Ok(m) => {
				return m;
			}
			FileNotFound => {
				ErrorBuilder.new()
					.puts(onError)
					.puts(path)
					.ln()
					.exit<void>();
				return null;
			}
			ParseError(code, path, section, error_index, error_pos, error_msg) => {
				ErrorBuilder.new()
					.render(code, path, section, error_index, error_pos, error_msg)
					.exit<void>();
				return null;
			}
		}
	}
	private def parseMonitorArgs(entry: MonitorRegistryEntry, args: string) {
		var s = 0, pos = 0;
		var arg: string;
		while (pos < args.length) {
			match (args[pos]) {
				',' => {
					arg = Arrays.prepend('-', Arrays.range(args, s, pos));
					entry.options.o.parseOption(arg);
					s = ++pos;
				}
				_ => pos++;
			}
		}
		if (s < args.length) {
			arg =Arrays.prepend('-', Arrays.range(args, s, args.length));
			var result = entry.options.o.parseOption(arg);
		}
	}
	// Get the monitors, if any, configured by the above.
	def getMonitors() -> Vector<Monitor> {
		return monitors;
	}
	def printHelp(out: TraceBuilder) {
		var H = out.putsln, L = out.ln;
		H("Wizard offers instrumentation and dynamic analyses of Wasm programs via monitors.");
		H("Multiple monitors can enabled simultaneously using the command-line flag.");
		L();
		H("   --monitors=<monitor>{<opts>}[,<monitor>{<opts>}]");
		L();
		H("Each monitor comes with its own set of optional arguments and their modifiers.");
		H("This build of the Wizard engine supports the following monitors:");
		L();

		MonitorRegistry.printHelp();

		L();
		H("Additional global monitor options include:");
		L();
		group.print(out, false);
		
		H("Example usage:");
		L();
		H("   --monitors=loops,coverage{code=instr}");
		out.ln();

		L();
		H("A Whamm monitor can also be used, which is provided as a path to a Wasm module.");
		H("If the module must be dynamically linked with support libraries, append paths to");
		H("those libraries delimited with '+'.");
		H("The Whamm monitor module should come FIRST in this list.");
		L();
		H("Example usage:");
		L();
		H("   --monitors=path/to/whamm-monitor.wasm+path/to/lib.wasm");
		L();
	}
}
